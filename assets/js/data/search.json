[ { "title": "My home server (host OS and pfSense)", "url": "/posts/homeserver-router/", "categories": "linux", "tags": "linux, pfSense, homeserver", "date": "2022-02-18 12:00:00 +0100", "snippet": "In this post I want to show you how you can set up a pfSense VM as your firewall and router and my first step in upgrading my home network and server.A quick overview of the steps we are going to take: Set up Ubuntu as host system Configure network bridges with netplan Set up a KVM VM with libvert for pfSense Install pfSense1. Set up Ubuntu as host systemFor my host OS I’m using Ubuntu Server 20.04 LTS.If you want to remotely manage your host OS, during the tnstall you should choose the option to install OpenSSH.After your host OS is intalled lets start installing all the packages we need:1. Lets get you up to date:sudo apt updatesudo apt upgrade2. Now get everything we might need installed:sudo apt install qemu bridge-utils libosinfo-bin virtinst libvirt-clients libvirt-deamon libvirt-deamon-system libvirt-sock libvirt-deamon-driver-qemu libvirt-deamon-driver-lxc2. Configure network bridges with netplanTo use the pfSense system we need to set up 2 bridges one for the WAN connection and one for the LAN.cd /etc/sudo cp -r netplan netplan.bucd netplanIn the netplan directory you should find the installer-config file. In this file we are going to add the bridges with the following steps:First you should deaktivate dhcp on your interfaces.We don’t need the physical LAN interfaces to have an IP, because we want to connect directly to the bridge.The physical WAN interface can’t have an IP because the only device that should get an IP is the WAN interface of the pfSense mashine." }, { "title": "Writing my first kernel module [2/n] [WIP]", "url": "/posts/kernel-mod-2/", "categories": "linux, draft", "tags": "linux, kernel, draft", "date": "2021-12-10 12:00:00 +0100", "snippet": "In this post I want to go through how to get the kernel source-tree and how to build a kernel from it. For every one how doesn’t know yet: the kernel source-tree is a directory which contains all the source code needed to build a kernel.Before we start I recommend you create a directory for your self to work in. e.g. mkdir ~/kernelbldGetting the kernel source-treeI recommend to just get your kernel source-tree form “The Linux Ternel Archives” unless you have a need for a specific build.After downloading the source-tree you should have a compressed archive. Now go into the directory you created to work in and extract it with tar -xf ~/Downloads/linux-{version}.tar.xzWhat is in the source code?Let’s get an overview of the source tree:arch COPYING Documentation include Kbuild lib Makefile README security usrblock CREDITS drivers init Kconfig LICENSES mm samples sound virtcerts crypto fs ipc kernel MAINTAINERS net scripts toolsLets get an overview over these files:READMEThis file should be your first point of contact. Here it is documented how to find and build the documentation for the kernel.MAINTAINERSThis file lists all maintainers of the different modules found in the kernel. If you want to submit a patch this file also provide a guide on how to do so.COPYINGThis file provides the licenses under which the kernel is released.MakefileThis is the top-level make file that is used by the kernel build system (we will discuss that in more detail later) and the kernel modules.[WIP]…Lets build that thingConfigure the kernelHow to configure the kernel is a science in its self, so we are going to discuss this later. For now the important thing is to know that we already have a lot of proven configs delivered with the kernel source tree.We can find these in the source tree under linux-{version}/arch/{arch}/configs. You can copy the content of this file into the .config file in the root of the source tree and thereby get a good starting point for your config.Further config can be done through a provided UI. To access this UI you have to make it with make menuconfig. In this menu you have several options. Here is a quick overview: controlls   y includes n excludes m modularizes as LKM (...) requiers numeric input [.] not module capable [*] built-in [ ] excluded &amp;lt;.&amp;gt; module capable &amp;lt;*&amp;gt; built-in &amp;lt;M&amp;gt; module (LKM) &amp;lt; &amp;gt; excluded dependancys   {.} is a dependancy an needs to be LKM or built-in -*- is a dependancy an needs built-in Bulid a simple kernelNow by running make all in the source-tree root you will build vmlinux which is the uncompressed kernel file used for kernel debugging, modules which are all modules we previously marked as a module in the config and bzImage which is the compressed kernel image and the one used by the boot loader. I’d recommend you also pass the option -j [N] were N is the number of processes make will spawn. For my 4 core system with SMT I went for N = 8. You can find out how many processing units your PC has by using the nproc command. So in the end my command looked like this: make -j 8 all." }, { "title": "Writing my first kernel module [1/n]", "url": "/posts/Kernel-mod-1/", "categories": "Linux", "tags": "Linux, kernel, theory", "date": "2021-12-10 12:00:00 +0100", "snippet": "Here I want to tell you about the motivation for developing kernel modules and what the hell even the kernel is:1. What is a kernel?Before even starting to write a kernel module it is probably important to know what a kernel even is.In short the kernel is the part of the operating system that manages the hardware and facilitates the communication of the software that runs on the system with that hardware.For us the most important job of the kernel will probably be memory management which entails the segregation of virtual memory into user space and kernel space. Why this is done we might go into at a later point.Another important job of the kernel is the interaction with devices through devices drivers.We can in general differentiate between 3 differentiate kernel structures:1. Monolithic kernelHere all features of the OS like the file system, scheduler, device drivers, memory management, basic and application inter process communication,… run in kernel mode.2. Micro kernelHere the features of the OS are split into a minimal kernel which only possesses basic functionality like the scheduler, memory management and basic IPC leaving a minimal amount running in kernel mode.The rest of the functionality of the OS is handled by “servers” like a file system server or device drivers running in user mode.3. Hybrid kernelA hybrid kernel tries to combine the benefits of the monolithic and micro kernel.2. What else is needed for a working Linux?In addition to the kernel there are 2 other components needed for any working Linux system. These are:1. The boot loaderThe boot loader is a small program that is started after the computer is turned on. Its functionality is to initiate the RAM and the non-volatile memory so that the components of the OS can be loaded.2. The root file systemThe root file system is the point on which all other file systems are mounted and together with the root directory / it forms the basis for the hierarchical file tree. Not to be confused with the home directory of the root user /root." }, { "title": "Welcome to my Blog!", "url": "/posts/first-post/", "categories": "general", "tags": "general", "date": "2021-12-09 14:23:00 +0100", "snippet": "There isn’t much to say yet, but the goal of my blog is to document some of my personal projects.Hopefully can also learn something on the way." } ]
